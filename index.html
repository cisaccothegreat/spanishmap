<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Spanish Verb Mind Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
            color: white;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        #container.dragging {
            cursor: grabbing;
        }

        #canvas-wrapper {
            position: absolute;
            width: 200%;
            height: 200%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.3s ease-out;
        }

        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4000px;
            height: 4000px;
            transform: translate(-50%, -50%);
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        svg line {
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 2;
        }

        /* Controls */
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* Title */
        .title {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Node styles */
        .node {
            position: absolute;
            padding: 15px 25px;
            border-radius: 25px;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            white-space: nowrap;
            user-select: none;
            z-index: 10;
        }

        .node:hover {
            transform: scale(1.05) translate(-50%, -50%);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            z-index: 20;
        }

        /* Center node */
        .center-node {
            font-size: 1.8em;
            padding: 30px 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            min-width: 200px;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Tense nodes */
        .tense-node {
            font-size: 1.3em;
        }

        /* Category nodes (Regular/Irregular) */
        .category-node {
            font-size: 1.1em;
        }

        .regular-node {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .irregular-node {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
        }

        /* Verb ending nodes */
        .ending-node {
            font-size: 1em;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        /* Irregular verb nodes */
        .verb-node {
            font-size: 0.95em;
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #333;
        }

        /* Conjugation detail box */
        .conjugation-box {
            position: fixed;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            min-width: 250px;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            display: none;
        }

        .conjugation-box.visible {
            display: block;
        }

        .conjugation-box h3 {
            margin-bottom: 15px;
            color: #ffd700;
            font-size: 1.2em;
        }

        .conjugation-list {
            display: grid;
            grid-template-columns: auto auto;
            gap: 8px;
            font-size: 0.9em;
        }

        .pronoun {
            color: #888;
        }

        .verb-form {
            color: #fff;
            font-weight: bold;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 15px 30px;
            font-size: 0.9em;
            text-align: center;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            .node {
                font-size: 0.85em;
                padding: 10px 15px;
            }

            .center-node {
                font-size: 1.2em;
                min-width: 150px;
                min-height: 150px;
                padding: 20px 30px;
            }

            .instructions {
                font-size: 0.8em;
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="title">üá™üá∏ Spanish Verb Map</div>

    <div class="controls">
        <button class="control-btn" onclick="zoomIn()">+</button>
        <button class="control-btn" onclick="zoomOut()">‚àí</button>
        <button class="control-btn" onclick="resetView()">‚ü≤</button>
    </div>

    <div class="instructions">
        üñ±Ô∏è Drag to move ‚Ä¢ üñ±Ô∏è Scroll to zoom ‚Ä¢ üñ±Ô∏è Click nodes to explore
    </div>

    <div id="container">
        <div id="canvas-wrapper">
            <div id="canvas">
                <svg id="lines" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
        </div>
    </div>

    <script>
        // Data structure for verbs
        const verbData = {
            presente: {
                regular: {
                    ar: {
                        example: 'HABLAR',
                        conjugations: [
                            ['yo', 'hablo'],
                            ['t√∫', 'hablas'],
                            ['√©l/ella/usted', 'habla'],
                            ['nosotros/as', 'hablamos'],
                            ['vosotros/as', 'habl√°is'],
                            ['ellos/ellas/ustedes', 'hablan']
                        ]
                    },
                    er: {
                        example: 'COMER',
                        conjugations: [
                            ['yo', 'como'],
                            ['t√∫', 'comes'],
                            ['√©l/ella/usted', 'come'],
                            ['nosotros/as', 'comemos'],
                            ['vosotros/as', 'com√©is'],
                            ['ellos/ellas/ustedes', 'comen']
                        ]
                    },
                    ir: {
                        example: 'VIVIR',
                        conjugations: [
                            ['yo', 'vivo'],
                            ['t√∫', 'vives'],
                            ['√©l/ella/usted', 'vive'],
                            ['nosotros/as', 'vivimos'],
                            ['vosotros/as', 'viv√≠s'],
                            ['ellos/ellas/ustedes', 'viven']
                        ]
                    }
                },
                irregular: {
                    ser: {
                        name: 'SER',
                        conjugations: [
                            ['yo', 'soy'],
                            ['t√∫', 'eres'],
                            ['√©l/ella/usted', 'es'],
                            ['nosotros/as', 'somos'],
                            ['vosotros/as', 'sois'],
                            ['ellos/ellas/ustedes', 'son']
                        ]
                    },
                    estar: {
                        name: 'ESTAR',
                        conjugations: [
                            ['yo', 'estoy'],
                            ['t√∫', 'est√°s'],
                            ['√©l/ella/usted', 'est√°'],
                            ['nosotros/as', 'estamos'],
                            ['vosotros/as', 'est√°is'],
                            ['ellos/ellas/ustedes', 'est√°n']
                        ]
                    },
                    hacer: {
                        name: 'HACER',
                        conjugations: [
                            ['yo', 'hago'],
                            ['t√∫', 'haces'],
                            ['√©l/ella/usted', 'hace'],
                            ['nosotros/as', 'hacemos'],
                            ['vosotros/as', 'hac√©is'],
                            ['ellos/ellas/ustedes', 'hacen']
                        ]
                    },
                    ir: {
                        name: 'IR',
                        conjugations: [
                            ['yo', 'voy'],
                            ['t√∫', 'vas'],
                            ['√©l/ella/usted', 'va'],
                            ['nosotros/as', 'vamos'],
                            ['vosotros/as', 'vais'],
                            ['ellos/ellas/ustedes', 'van']
                        ]
                    },
                    tener: {
                        name: 'TENER',
                        conjugations: [
                            ['yo', 'tengo'],
                            ['t√∫', 'tienes'],
                            ['√©l/ella/usted', 'tiene'],
                            ['nosotros/as', 'tenemos'],
                            ['vosotros/as', 'ten√©is'],
                            ['ellos/ellas/ustedes', 'tienen']
                        ]
                    }
                }
            }
        };

        // Canvas state
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let startX, startY;
        let expandedTenses = new Set();
        let expandedCategories = new Set();
        let manualControl = false;

        const container = document.getElementById('container');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvas = document.getElementById('canvas');
        const linesContainer = document.getElementById('lines');

        // Center of canvas
        const CENTER_X = 2000;
        const CENTER_Y = 2000;

        // Tense names and colors
        const tenses = [
            { name: 'PRESENTE', color: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)' },
            { name: 'PRET√âRITO', color: 'linear-gradient(135deg, #ee0979 0%, #ff6a00 100%)' },
            { name: 'IMPERFECTO', color: 'linear-gradient(135deg, #fc4a1a 0%, #f7b733 100%)' },
            { name: 'PRET√âRITO PERFECTO', color: 'linear-gradient(135deg, #4776e6 0%, #8e54e9 100%)' },
            { name: 'PLUSCUAMPERFECTO', color: 'linear-gradient(135deg, #134e5e 0%, #71b280 100%)' },
            { name: 'FUTURO', color: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)' },
            { name: 'CONDICIONAL', color: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)' },
            { name: 'IMPERFECTO DE SUBJUNTIVO', color: 'linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%)' }
        ];

        // Dynamic radius calculation
        function getBaseRadius() {
            const expandedCount = expandedTenses.size;
            const categoryCount = expandedCategories.size;
            return 400 + (expandedCount * 100) + (categoryCount * 50);
        }

        function getCategoryRadius() {
            const categoryCount = expandedCategories.size;
            return 250 + (categoryCount * 40);
        }

        function getVerbRadius() {
            const categoryCount = expandedCategories.size;
            return 200 + (categoryCount * 30);
        }

        // Create center node
        const centerNode = createNode('SPANISH VERBS', CENTER_X, CENTER_Y, 'center-node');
        canvas.appendChild(centerNode);

        // Store tense nodes for repositioning
        const tenseNodes = [];

        // Create all tense nodes in a circle around center
        tenses.forEach((tense, index) => {
            const angle = (index / tenses.length) * Math.PI * 2 - Math.PI / 2;
            const radius = getBaseRadius();
            const x = CENTER_X + Math.cos(angle) * radius;
            const y = CENTER_Y + Math.sin(angle) * radius;
            
            const tenseNode = createNode(tense.name, x, y, 'tense-node');
            tenseNode.style.background = tense.color;
            tenseNode.dataset.tense = tense.name.toLowerCase().replace(/\s+/g, '-');
            tenseNode.dataset.expanded = 'false';
            tenseNode.dataset.angle = angle;
            
            tenseNode.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleTenseExpansion(tenseNode);
            });
            
            canvas.appendChild(tenseNode);
            
            // Create line from center to tense
            const line = drawLine(CENTER_X, CENTER_Y, x, y);
            line.dataset.lineType = 'tense';
            line.dataset.tenseId = tenseNode.dataset.tense;
            
            tenseNodes.push({
                node: tenseNode,
                line: line,
                angle: angle,
                tense: tense
            });
        });

        // Functions
        function createNode(text, x, y, className) {
            const node = document.createElement('div');
            node.className = `node ${className}`;
            node.textContent = text;
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            node.style.transform = 'translate(-50%, -50%)';
            
            return node;
        }

        function drawLine(x1, y1, x2, y2, parentTense = null, parentCategory = null) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            if (parentTense) line.dataset.parentTense = parentTense;
            if (parentCategory) line.dataset.parentCategory = parentCategory;
            linesContainer.appendChild(line);
            return line;
        }

        function repositionTenses() {
            const newRadius = getBaseRadius();
            tenseNodes.forEach(({ node, line, angle }) => {
                const x = CENTER_X + Math.cos(angle) * newRadius;
                const y = CENTER_Y + Math.sin(angle) * newRadius;
                
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                line.setAttribute('x2', x);
                line.setAttribute('y2', y);
            });
        }

        function autoZoom() {
            if (manualControl) return;
            
            const expandedCount = expandedTenses.size + expandedCategories.size;
            
            if (expandedCount === 0) {
                scale = 1;
            } else if (expandedCount <= 2) {
                scale = 0.8;
            } else if (expandedCount <= 5) {
                scale = 0.6;
            } else if (expandedCount <= 10) {
                scale = 0.45;
            } else {
                scale = 0.35;
            }
            
            translateX = 0;
            translateY = 0;
            updateTransform();
        }

        function toggleTenseExpansion(tenseNode) {
            const tenseName = tenseNode.dataset.tense;
            const isExpanded = tenseNode.dataset.expanded === 'true';
            const angle = parseFloat(tenseNode.dataset.angle);
            const radius = getBaseRadius();
            const tenseX = CENTER_X + Math.cos(angle) * radius;
            const tenseY = CENTER_Y + Math.sin(angle) * radius;

            if (isExpanded) {
                // Collapse
                expandedTenses.delete(tenseName);
                
                const childNodes = canvas.querySelectorAll(`[data-parent-tense="${tenseName}"]`);
                childNodes.forEach(node => {
                    if (node.dataset.category) {
                        expandedCategories.delete(`${tenseName}-${node.dataset.category}`);
                    }
                    node.remove();
                });
                
                const lines = linesContainer.querySelectorAll(`[data-parent-tense="${tenseName}"]`);
                lines.forEach(line => line.remove());
                
                tenseNode.dataset.expanded = 'false';
            } else {
                // Expand
                expandedTenses.add(tenseName);
                tenseNode.dataset.expanded = 'true';

                const offsetDistance = getCategoryRadius();
                const perpAngle1 = angle + Math.PI / 6;
                const perpAngle2 = angle - Math.PI / 6;

                const regularX = tenseX + Math.cos(perpAngle1) * offsetDistance;
                const regularY = tenseY + Math.sin(perpAngle1) * offsetDistance;
                const irregularX = tenseX + Math.cos(perpAngle2) * offsetDistance;
                const irregularY = tenseY + Math.sin(perpAngle2) * offsetDistance;

                // Create Regular node
                const regularNode = createNode('REGULAR', regularX, regularY, 'category-node regular-node');
                regularNode.dataset.category = 'regular';
                regularNode.dataset.tense = tenseName;
                regularNode.dataset.parentTense = tenseName;
                regularNode.dataset.expanded = 'false';
                regularNode.dataset.baseX = regularX;
                regularNode.dataset.baseY = regularY;
                regularNode.dataset.baseAngle = perpAngle1;
                regularNode.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCategoryExpansion(regularNode, tenseName, 'regular');
                });
                canvas.appendChild(regularNode);
                const regLine = drawLine(tenseX, tenseY, regularX, regularY, tenseName);
                regLine.dataset.lineType = 'category';

                // Create Irregular node
                const irregularNode = createNode('IRREGULAR', irregularX, irregularY, 'category-node irregular-node');
                irregularNode.dataset.category = 'irregular';
                irregularNode.dataset.tense = tenseName;
                irregularNode.dataset.parentTense = tenseName;
                irregularNode.dataset.expanded = 'false';
                irregularNode.dataset.baseX = irregularX;
                irregularNode.dataset.baseY = irregularY;
                irregularNode.dataset.baseAngle = perpAngle2;
                irregularNode.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCategoryExpansion(irregularNode, tenseName, 'irregular');
                });
                canvas.appendChild(irregularNode);
                const irregLine = drawLine(tenseX, tenseY, irregularX, irregularY, tenseName);
                irregLine.dataset.lineType = 'category';
            }
            
            repositionTenses();
            autoZoom();
        }

        function toggleCategoryExpansion(categoryNode, tenseName, category) {
            const isExpanded = categoryNode.dataset.expanded === 'true';
            const nodeId = `${tenseName}-${category}`;
            const catX = parseFloat(categoryNode.dataset.baseX);
            const catY = parseFloat(categoryNode.dataset.baseY);
            const baseAngle = parseFloat(categoryNode.dataset.baseAngle);

            if (isExpanded) {
                // Collapse
                expandedCategories.delete(nodeId);
                
                const childNodes = canvas.querySelectorAll(`[data-parent-category="${nodeId}"]`);
                childNodes.forEach(node => node.remove());
                
                const lines = linesContainer.querySelectorAll(`[data-parent-category="${nodeId}"]`);
                lines.forEach(line => line.remove());
                
                categoryNode.dataset.expanded = 'false';
            } else {
                // Expand
                expandedCategories.add(nodeId);
                categoryNode.dataset.expanded = 'true';

                if (category === 'regular') {
                    // Show -AR, -ER, -IR
                    const endings = ['ar', 'er', 'ir'];
                    const endingRadius = getVerbRadius();
                    
                    endings.forEach((ending, index) => {
                        const angle = baseAngle + (index - 1) * (Math.PI / 8);
                        const x = catX + Math.cos(angle) * endingRadius;
                        const y = catY + Math.sin(angle) * endingRadius;
                        
                        const example = verbData.presente.regular[ending].example;
                        const endingNode = createNode(`-${ending.toUpperCase()}\n(${example})`, x, y, 'ending-node');
                        endingNode.dataset.ending = ending;
                        endingNode.dataset.tense = tenseName;
                        endingNode.dataset.parentTense = tenseName;
                        endingNode.dataset.parentCategory = nodeId;
                        endingNode.addEventListener('click', (e) => {
                            e.stopPropagation();
                            showConjugation(endingNode);
                        });
                        canvas.appendChild(endingNode);
                        drawLine(catX, catY, x, y, tenseName, nodeId);
                    });
                } else {
                    // Show irregular verbs
                    const irregularVerbs = Object.keys(verbData.presente.irregular);
                    const verbRadius = getVerbRadius();
                    
                    irregularVerbs.forEach((verb, index) => {
                        const totalVerbs = irregularVerbs.length;
                        const angle = baseAngle + ((index - (totalVerbs - 1) / 2) * (Math.PI / 12));
                        const x = catX + Math.cos(angle) * verbRadius;
                        const y = catY + Math.sin(angle) * verbRadius;
                        
                        const verbNode = createNode(verbData.presente.irregular[verb].name, x, y, 'verb-node');
                        verbNode.dataset.verb = verb;
                        verbNode.dataset.tense = tenseName;
                        verbNode.dataset.parentTense = tenseName;
                        verbNode.dataset.parentCategory = nodeId;
                        verbNode.addEventListener('click', (e) => {
                            e.stopPropagation();
                            showConjugation(verbNode);
                        });
                        canvas.appendChild(verbNode);
                        drawLine(catX, catY, x, y, tenseName, nodeId);
                    });
                }
            }
            
            repositionTenses();
            autoZoom();
        }

        function showConjugation(node) {
            document.querySelectorAll('.conjugation-box').forEach(box => box.remove());

            let conjugationData = null;
            let title = '';

            if (node.dataset.ending) {
                const ending = node.dataset.ending;
                conjugationData = verbData.presente.regular[ending].conjugations;
                title = verbData.presente.regular[ending].example;
            } else if (node.dataset.verb) {
                const verb = node.dataset.verb;
                conjugationData = verbData.presente.irregular[verb].conjugations;
                title = verbData.presente.irregular[verb].name;
            }

            if (conjugationData) {
                const box = document.createElement('div');
                box.className = 'conjugation-box visible';
                
                const rect = node.getBoundingClientRect();
                box.style.left = `${rect.right + 20}px`;
                box.style.top = `${rect.top}px`;

                let html = `
                    <button class="close-btn" onclick="this.parentElement.remove()">√ó</button>
                    <h3>${title}</h3>
                    <div class="conjugation-list">
                `;

                conjugationData.forEach(([pronoun, form]) => {
                    html += `
                        <span class="pronoun">${pronoun}</span>
                        <span class="verb-form">${form}</span>
                    `;
                });

                html += '</div>';
                box.innerHTML = html;
                document.body.appendChild(box);
            }
        }

        function updateTransform() {
            canvasWrapper.style.transform = `translate(calc(-50% + ${translateX}px), calc(-50% + ${translateY}px)) scale(${scale})`;
        }

        function zoomIn() {
            scale = Math.min(scale * 1.2, 3);
            manualControl = true;
            updateTransform();
        }

        function zoomOut() {
            scale = Math.max(scale / 1.2, 0.2);
            manualControl = true;
            updateTransform();
        }

        function resetView() {
            scale = 1;
            translateX = 0;
            translateY = 0;
            manualControl = false;
            updateTransform();
            autoZoom();
        }

        // Dragging
        container.addEventListener('mousedown', (e) => {
            if (e.target === container || e.target === canvasWrapper || e.target === canvas || e.target.tagName === 'svg') {
                isDragging = true;
                startX = e.clientX - translateX;
                startY = e.clientY - translateY;
                container.classList.add('dragging');
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                translateX = e.clientX - startX;
                translateY = e.clientY - startY;
                updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                manualControl = true;
            }
            isDragging = false;
            container.classList.remove('dragging');
        });

        // Zoom with mouse wheel
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale = Math.max(0.2, Math.min(3, scale * delta));
            manualControl = true;
            updateTransform();
        });

        // Touch support for mobile
        let touchStartDist = 0;
        
        container.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                touchStartDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            } else if (e.touches.length === 1) {
                isDragging = true;
                startX = e.touches[0].clientX - translateX;
                startY = e.touches[0].clientY - translateY;
            }
        });

        container.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2 && touchStartDist > 0) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                scale = Math.max(0.2, Math.min(3, scale * (dist / touchStartDist)));
                touchStartDist = dist;
                manualControl = true;
                updateTransform();
            } else if (e.touches.length === 1 && isDragging) {
                translateX = e.touches[0].clientX - startX;
                translateY = e.touches[0].clientY - startY;
                updateTransform();
            }
        });

        container.addEventListener('touchend', () => {
            if (isDragging || touchStartDist > 0) {
                manualControl = true;
            }
            isDragging = false;
            touchStartDist = 0;
        });
    </script>
</body>
</html>
