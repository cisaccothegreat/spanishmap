<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Spanish Verb Mind Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
            color: white;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        #container.dragging {
            cursor: grabbing;
        }

        #canvas-wrapper {
            position: absolute;
            width: 200%;
            height: 200%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.3s ease-out;
        }

        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6000px;
            height: 6000px;
            transform: translate(-50%, -50%);
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        svg line {
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 2;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .title {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .node {
            position: absolute;
            padding: 15px 25px;
            border-radius: 25px;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            white-space: nowrap;
            user-select: none;
            z-index: 10;
        }

        .node:hover {
            transform: scale(1.05) translate(-50%, -50%);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            z-index: 20;
        }

        .center-node {
            font-size: 1.8em;
            padding: 30px 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            min-width: 200px;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tense-node {
            font-size: 1.2em;
        }

        .category-node {
            font-size: 1.1em;
        }

        .regular-node {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .irregular-node {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
        }

        .ending-node {
            font-size: 1em;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .verb-node {
            font-size: 0.95em;
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #333;
        }

        .conjugation-box {
            position: fixed;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            min-width: 250px;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            display: none;
        }

        .conjugation-box.visible {
            display: block;
        }

        .conjugation-box h3 {
            margin-bottom: 15px;
            color: #ffd700;
            font-size: 1.2em;
        }

        .conjugation-list {
            display: grid;
            grid-template-columns: auto auto;
            gap: 8px;
            font-size: 0.9em;
        }

        .pronoun {
            color: #888;
        }

        .verb-form {
            color: #fff;
            font-weight: bold;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 15px 30px;
            font-size: 0.9em;
            text-align: center;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            .node {
                font-size: 0.85em;
                padding: 10px 15px;
            }

            .center-node {
                font-size: 1.2em;
                min-width: 150px;
                min-height: 150px;
                padding: 20px 30px;
            }

            .instructions {
                font-size: 0.8em;
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="title">üá™üá∏ Spanish Verb Map</div>

    <div class="controls">
        <button class="control-btn" onclick="zoomIn()">+</button>
        <button class="control-btn" onclick="zoomOut()">‚àí</button>
        <button class="control-btn" onclick="resetView()">‚ü≤</button>
    </div>

    <div class="instructions">
        üñ±Ô∏è Drag to move ‚Ä¢ üñ±Ô∏è Scroll to zoom ‚Ä¢ üñ±Ô∏è Click nodes to explore
    </div>

    <div id="container">
        <div id="canvas-wrapper">
            <div id="canvas">
                <svg id="lines" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
        </div>
    </div>

    <script src="data:text/javascript;base64,Ly8gVmVyYiBkYXRhIHdpbGwgYmUgaW5qZWN0ZWQgaGVyZQ=="></script>
    <script>
        // VERB DATA - Complete conjugations for all tenses
        const verbData = {
            presente: {
                regular: {
                    ar: { example: 'HABLAR', conjugations: [['yo', 'hablo'], ['t√∫', 'hablas'], ['√©l/ella/usted', 'habla'], ['nosotros/as', 'hablamos'], ['vosotros/as', 'habl√°is'], ['ellos/ellas/ustedes', 'hablan']] },
                    er: { example: 'COMER', conjugations: [['yo', 'como'], ['t√∫', 'comes'], ['√©l/ella/usted', 'come'], ['nosotros/as', 'comemos'], ['vosotros/as', 'com√©is'], ['ellos/ellas/ustedes', 'comen']] },
                    ir: { example: 'VIVIR', conjugations: [['yo', 'vivo'], ['t√∫', 'vives'], ['√©l/ella/usted', 'vive'], ['nosotros/as', 'vivimos'], ['vosotros/as', 'viv√≠s'], ['ellos/ellas/ustedes', 'viven']] }
                },
                irregular: {
                    ser: { name: 'SER', conjugations: [['yo', 'soy'], ['t√∫', 'eres'], ['√©l/ella/usted', 'es'], ['nosotros/as', 'somos'], ['vosotros/as', 'sois'], ['ellos/ellas/ustedes', 'son']] },
                    estar: { name: 'ESTAR', conjugations: [['yo', 'estoy'], ['t√∫', 'est√°s'], ['√©l/ella/usted', 'est√°'], ['nosotros/as', 'estamos'], ['vosotros/as', 'est√°is'], ['ellos/ellas/ustedes', 'est√°n']] },
                    hacer: { name: 'HACER', conjugations: [['yo', 'hago'], ['t√∫', 'haces'], ['√©l/ella/usted', 'hace'], ['nosotros/as', 'hacemos'], ['vosotros/as', 'hac√©is'], ['ellos/ellas/ustedes', 'hacen']] },
                    ir: { name: 'IR', conjugations: [['yo', 'voy'], ['t√∫', 'vas'], ['√©l/ella/usted', 'va'], ['nosotros/as', 'vamos'], ['vosotros/as', 'vais'], ['ellos/ellas/ustedes', 'van']] },
                    tener: { name: 'TENER', conjugations: [['yo', 'tengo'], ['t√∫', 'tienes'], ['√©l/ella/usted', 'tiene'], ['nosotros/as', 'tenemos'], ['vosotros/as', 'ten√©is'], ['ellos/ellas/ustedes', 'tienen']] }
                }
            },
            pret√©rito: {
                regular: {
                    ar: { example: 'HABLAR', conjugations: [['yo', 'habl√©'], ['t√∫', 'hablaste'], ['√©l/ella/usted', 'habl√≥'], ['nosotros/as', 'hablamos'], ['vosotros/as', 'hablasteis'], ['ellos/ellas/ustedes', 'hablaron']] },
                    er: { example: 'COMER', conjugations: [['yo', 'com√≠'], ['t√∫', 'comiste'], ['√©l/ella/usted', 'comi√≥'], ['nosotros/as', 'comimos'], ['vosotros/as', 'comisteis'], ['ellos/ellas/ustedes', 'comieron']] },
                    ir: { example: 'VIVIR', conjugations: [['yo', 'viv√≠'], ['t√∫', 'viviste'], ['√©l/ella/usted', 'vivi√≥'], ['nosotros/as', 'vivimos'], ['vosotros/as', 'vivisteis'], ['ellos/ellas/ustedes', 'vivieron']] }
                },
                irregular: {
                    ser: { name: 'SER/IR', conjugations: [['yo', 'fui'], ['t√∫', 'fuiste'], ['√©l/ella/usted', 'fue'], ['nosotros/as', 'fuimos'], ['vosotros/as', 'fuisteis'], ['ellos/ellas/ustedes', 'fueron']] },
                    estar: { name: 'ESTAR', conjugations: [['yo', 'estuve'], ['t√∫', 'estuviste'], ['√©l/ella/usted', 'estuvo'], ['nosotros/as', 'estuvimos'], ['vosotros/as', 'estuvisteis'], ['ellos/ellas/ustedes', 'estuvieron']] },
                    hacer: { name: 'HACER', conjugations: [['yo', 'hice'], ['t√∫', 'hiciste'], ['√©l/ella/usted', 'hizo'], ['nosotros/as', 'hicimos'], ['vosotros/as', 'hicisteis'], ['ellos/ellas/ustedes', 'hicieron']] },
                    tener: { name: 'TENER', conjugations: [['yo', 'tuve'], ['t√∫', 'tuviste'], ['√©l/ella/usted', 'tuvo'], ['nosotros/as', 'tuvimos'], ['vosotros/as', 'tuvisteis'], ['ellos/ellas/ustedes', 'tuvieron']] },
                    poder: { name: 'PODER', conjugations: [['yo', 'pude'], ['t√∫', 'pudiste'], ['√©l/ella/usted', 'pudo'], ['nosotros/as', 'pudimos'], ['vosotros/as', 'pudisteis'], ['ellos/ellas/ustedes', 'pudieron']] }
                }
            },
            imperfecto: {
                regular: {
                    ar: { example: 'HABLAR', conjugations: [['yo', 'hablaba'], ['t√∫', 'hablabas'], ['√©l/ella/usted', 'hablaba'], ['nosotros/as', 'habl√°bamos'], ['vosotros/as', 'hablabais'], ['ellos/ellas/ustedes', 'hablaban']] },
                    er: { example: 'COMER', conjugations: [['yo', 'com√≠a'], ['t√∫', 'com√≠as'], ['√©l/ella/usted', 'com√≠a'], ['nosotros/as', 'com√≠amos'], ['vosotros/as', 'com√≠ais'], ['ellos/ellas/ustedes', 'com√≠an']] },
                    ir: { example: 'VIVIR', conjugations: [['yo', 'viv√≠a'], ['t√∫', 'viv√≠as'], ['√©l/ella/usted', 'viv√≠a'], ['nosotros/as', 'viv√≠amos'], ['vosotros/as', 'viv√≠ais'], ['ellos/ellas/ustedes', 'viv√≠an']] }
                },
                irregular: {
                    ser: { name: 'SER', conjugations: [['yo', 'era'], ['t√∫', 'eras'], ['√©l/ella/usted', 'era'], ['nosotros/as', '√©ramos'], ['vosotros/as', 'erais'], ['ellos/ellas/ustedes', 'eran']] },
                    ir: { name: 'IR', conjugations: [['yo', 'iba'], ['t√∫', 'ibas'], ['√©l/ella/usted', 'iba'], ['nosotros/as', '√≠bamos'], ['vosotros/as', 'ibais'], ['ellos/ellas/ustedes', 'iban']] },
                    ver: { name: 'VER', conjugations: [['yo', 've√≠a'], ['t√∫', 've√≠as'], ['√©l/ella/usted', 've√≠a'], ['nosotros/as', 've√≠amos'], ['vosotros/as', 've√≠ais'], ['ellos/ellas/ustedes', 've√≠an']] }
                }
            },
            futuro: {
                regular: {
                    ar: { example: 'HABLAR', conjugations: [['yo', 'hablar√©'], ['t√∫', 'hablar√°s'], ['√©l/ella/usted', 'hablar√°'], ['nosotros/as', 'hablaremos'], ['vosotros/as', 'hablar√©is'], ['ellos/ellas/ustedes', 'hablar√°n']] },
                    er: { example: 'COMER', conjugations: [['yo', 'comer√©'], ['t√∫', 'comer√°s'], ['√©l/ella/usted', 'comer√°'], ['nosotros/as', 'comeremos'], ['vosotros/as', 'comer√©is'], ['ellos/ellas/ustedes', 'comer√°n']] },
                    ir: { example: 'VIVIR', conjugations: [['yo', 'vivir√©'], ['t√∫', 'vivir√°s'], ['√©l/ella/usted', 'vivir√°'], ['nosotros/as', 'viviremos'], ['vosotros/as', 'vivir√©is'], ['ellos/ellas/ustedes', 'vivir√°n']] }
                },
                irregular: {
                    hacer: { name: 'HACER', conjugations: [['yo', 'har√©'], ['t√∫', 'har√°s'], ['√©l/ella/usted', 'har√°'], ['nosotros/as', 'haremos'], ['vosotros/as', 'har√©is'], ['ellos/ellas/ustedes', 'har√°n']] },
                    tener: { name: 'TENER', conjugations: [['yo', 'tendr√©'], ['t√∫', 'tendr√°s'], ['√©l/ella/usted', 'tendr√°'], ['nosotros/as', 'tendremos'], ['vosotros/as', 'tendr√©is'], ['ellos/ellas/ustedes', 'tendr√°n']] },
                    poder: { name: 'PODER', conjugations: [['yo', 'podr√©'], ['t√∫', 'podr√°s'], ['√©l/ella/usted', 'podr√°'], ['nosotros/as', 'podremos'], ['vosotros/as', 'podr√©is'], ['ellos/ellas/ustedes', 'podr√°n']] },
                    decir: { name: 'DECIR', conjugations: [['yo', 'dir√©'], ['t√∫', 'dir√°s'], ['√©l/ella/usted', 'dir√°'], ['nosotros/as', 'diremos'], ['vosotros/as', 'dir√©is'], ['ellos/ellas/ustedes', 'dir√°n']] },
                    poner: { name: 'PONER', conjugations: [['yo', 'pondr√©'], ['t√∫', 'pondr√°s'], ['√©l/ella/usted', 'pondr√°'], ['nosotros/as', 'pondremos'], ['vosotros/as', 'pondr√©is'], ['ellos/ellas/ustedes', 'pondr√°n']] }
                }
            },
            condicional: {
                regular: {
                    ar: { example: 'HABLAR', conjugations: [['yo', 'hablar√≠a'], ['t√∫', 'hablar√≠as'], ['√©l/ella/usted', 'hablar√≠a'], ['nosotros/as', 'hablar√≠amos'], ['vosotros/as', 'hablar√≠ais'], ['ellos/ellas/ustedes', 'hablar√≠an']] },
                    er: { example: 'COMER', conjugations: [['yo', 'comer√≠a'], ['t√∫', 'comer√≠as'], ['√©l/ella/usted', 'comer√≠a'], ['nosotros/as', 'comer√≠amos'], ['vosotros/as', 'comer√≠ais'], ['ellos/ellas/ustedes', 'comer√≠an']] },
                    ir: { example: 'VIVIR', conjugations: [['yo', 'vivir√≠a'], ['t√∫', 'vivir√≠as'], ['√©l/ella/usted', 'vivir√≠a'], ['nosotros/as', 'vivir√≠amos'], ['vosotros/as', 'vivir√≠ais'], ['ellos/ellas/ustedes', 'vivir√≠an']] }
                },
                irregular: {
                    hacer: { name: 'HACER', conjugations: [['yo', 'har√≠a'], ['t√∫', 'har√≠as'], ['√©l/ella/usted', 'har√≠a'], ['nosotros/as', 'har√≠amos'], ['vosotros/as', 'har√≠ais'], ['ellos/ellas/ustedes', 'har√≠an']] },
                    tener: { name: 'TENER', conjugations: [['yo', 'tendr√≠a'], ['t√∫', 'tendr√≠as'], ['√©l/ella/usted', 'tendr√≠a'], ['nosotros/as', 'tendr√≠amos'], ['vosotros/as', 'tendr√≠ais'], ['ellos/ellas/ustedes', 'tendr√≠an']] },
                    poder: { name: 'PODER', conjugations: [['yo', 'podr√≠a'], ['t√∫', 'podr√≠as'], ['√©l/ella/usted', 'podr√≠a'], ['nosotros/as', 'podr√≠amos'], ['vosotros/as', 'podr√≠ais'], ['ellos/ellas/ustedes', 'podr√≠an']] },
                    decir: { name: 'DECIR', conjugations: [['yo', 'dir√≠a'], ['t√∫', 'dir√≠as'], ['√©l/ella/usted', 'dir√≠a'], ['nosotros/as', 'dir√≠amos'], ['vosotros/as', 'dir√≠ais'], ['ellos/ellas/ustedes', 'dir√≠an']] },
                    poner: { name: 'PONER', conjugations: [['yo', 'pondr√≠a'], ['t√∫', 'pondr√≠as'], ['√©l/ella/usted', 'pondr√≠a'], ['nosotros/as', 'pondr√≠amos'], ['vosotros/as', 'pondr√≠ais'], ['ellos/ellas/ustedes', 'pondr√≠an']] }
                }
            },
            'imperfecto-de-subjuntivo': {
                regular: {
                    ar: { example: 'HABLAR', conjugations: [['yo', 'hablara'], ['t√∫', 'hablaras'], ['√©l/ella/usted', 'hablara'], ['nosotros/as', 'habl√°ramos'], ['vosotros/as', 'hablarais'], ['ellos/ellas/ustedes', 'hablaran']] },
                    er: { example: 'COMER', conjugations: [['yo', 'comiera'], ['t√∫', 'comieras'], ['√©l/ella/usted', 'comiera'], ['nosotros/as', 'comi√©ramos'], ['vosotros/as', 'comierais'], ['ellos/ellas/ustedes', 'comieran']] },
                    ir: { example: 'VIVIR', conjugations: [['yo', 'viviera'], ['t√∫', 'vivieras'], ['√©l/ella/usted', 'viviera'], ['nosotros/as', 'vivi√©ramos'], ['vosotros/as', 'vivierais'], ['ellos/ellas/ustedes', 'vivieran']] }
                },
                irregular: {
                    ser: { name: 'SER/IR', conjugations: [['yo', 'fuera'], ['t√∫', 'fueras'], ['√©l/ella/usted', 'fuera'], ['nosotros/as', 'fu√©ramos'], ['vosotros/as', 'fuerais'], ['ellos/ellas/ustedes', 'fueran']] },
                    tener: { name: 'TENER', conjugations: [['yo', 'tuviera'], ['t√∫', 'tuvieras'], ['√©l/ella/usted', 'tuviera'], ['nosotros/as', 'tuvi√©ramos'], ['vosotros/as', 'tuvierais'], ['ellos/ellas/ustedes', 'tuvieran']] },
                    hacer: { name: 'HACER', conjugations: [['yo', 'hiciera'], ['t√∫', 'hicieras'], ['√©l/ella/usted', 'hiciera'], ['nosotros/as', 'hici√©ramos'], ['vosotros/as', 'hicierais'], ['ellos/ellas/ustedes', 'hicieran']] },
                    poder: { name: 'PODER', conjugations: [['yo', 'pudiera'], ['t√∫', 'pudieras'], ['√©l/ella/usted', 'pudiera'], ['nosotros/as', 'pudi√©ramos'], ['vosotros/as', 'pudierais'], ['ellos/ellas/ustedes', 'pudieran']] }
                }
            },
            'pret√©rito-perfecto': {
                regular: {
                    ar: { example: 'HABLAR', conjugations: [['yo', 'he hablado'], ['t√∫', 'has hablado'], ['√©l/ella/usted', 'ha hablado'], ['nosotros/as', 'hemos hablado'], ['vosotros/as', 'hab√©is hablado'], ['ellos/ellas/ustedes', 'han hablado']] },
                    er: { example: 'COMER', conjugations: [['yo', 'he comido'], ['t√∫', 'has comido'], ['√©l/ella/usted', 'ha comido'], ['nosotros/as', 'hemos comido'], ['vosotros/as', 'hab√©is comido'], ['ellos/ellas/ustedes', 'han comido']] },
                    ir: { example: 'VIVIR', conjugations: [['yo', 'he vivido'], ['t√∫', 'has vivido'], ['√©l/ella/usted', 'ha vivido'], ['nosotros/as', 'hemos vivido'], ['vosotros/as', 'hab√©is vivido'], ['ellos/ellas/ustedes', 'han vivido']] }
                },
                irregular: {
                    hacer: { name: 'HACER', conjugations: [['yo', 'he hecho'], ['t√∫', 'has hecho'], ['√©l/ella/usted', 'ha hecho'], ['nosotros/as', 'hemos hecho'], ['vosotros/as', 'hab√©is hecho'], ['ellos/ellas/ustedes', 'han hecho']] },
                    ver: { name: 'VER', conjugations: [['yo', 'he visto'], ['t√∫', 'has visto'], ['√©l/ella/usted', 'ha visto'], ['nosotros/as', 'hemos visto'], ['vosotros/as', 'hab√©is visto'], ['ellos/ellas/ustedes', 'han visto']] },
                    escribir: { name: 'ESCRIBIR', conjugations: [['yo', 'he escrito'], ['t√∫', 'has escrito'], ['√©l/ella/usted', 'ha escrito'], ['nosotros/as', 'hemos escrito'], ['vosotros/as', 'hab√©is escrito'], ['ellos/ellas/ustedes', 'han escrito']] }
                }
            },
            pluscuamperfecto: {
                regular: {
                    ar: { example: 'HABLAR', conjugations: [['yo', 'hab√≠a hablado'], ['t√∫', 'hab√≠as hablado'], ['√©l/ella/usted', 'hab√≠a hablado'], ['nosotros/as', 'hab√≠amos hablado'], ['vosotros/as', 'hab√≠ais hablado'], ['ellos/ellas/ustedes', 'hab√≠an hablado']] },
                    er: { example: 'COMER', conjugations: [['yo', 'hab√≠a comido'], ['t√∫', 'hab√≠as comido'], ['√©l/ella/usted', 'hab√≠a comido'], ['nosotros/as', 'hab√≠amos comido'], ['vosotros/as', 'hab√≠ais comido'], ['ellos/ellas/ustedes', 'hab√≠an comido']] },
                    ir: { example: 'VIVIR', conjugations: [['yo', 'hab√≠a vivido'], ['t√∫', 'hab√≠as vivido'], ['√©l/ella/usted', 'hab√≠a vivido'], ['nosotros/as', 'hab√≠amos vivido'], ['vosotros/as', 'hab√≠ais vivido'], ['ellos/ellas/ustedes', 'hab√≠an vivido']] }
                },
                irregular: {
                    hacer: { name: 'HACER', conjugations: [['yo', 'hab√≠a hecho'], ['t√∫', 'hab√≠as hecho'], ['√©l/ella/usted', 'hab√≠a hecho'], ['nosotros/as', 'hab√≠amos hecho'], ['vosotros/as', 'hab√≠ais hecho'], ['ellos/ellas/ustedes', 'hab√≠an hecho']] },
                    ver: { name: 'VER', conjugations: [['yo', 'hab√≠a visto'], ['t√∫', 'hab√≠as visto'], ['√©l/ella/usted', 'hab√≠a visto'], ['nosotros/as', 'hab√≠amos visto'], ['vosotros/as', 'hab√≠ais visto'], ['ellos/ellas/ustedes', 'hab√≠an visto']] }
                }
            }
        };

        // Constants
        const CENTER_X = 3000;
        const CENTER_Y = 3000;
        const BASE_TENSE_RADIUS = 600;
        const BASE_CATEGORY_RADIUS = 450;
        const BASE_VERB_RADIUS = 350;

        // Canvas state
        let scale = 0.8; // Start zoomed out a bit
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let startX, startY;
        let manualControl = false;
        let expandedCount = 0;

        const container = document.getElementById('container');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvas = document.getElementById('canvas');
        const linesContainer = document.getElementById('lines');

        // Tenses configuration
        const tenses = [
            { name: 'PRESENTE', key: 'presente', color: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)' },
            { name: 'PRET√âRITO', key: 'pret√©rito', color: 'linear-gradient(135deg, #ee0979 0%, #ff6a00 100%)' },
            { name: 'IMPERFECTO', key: 'imperfecto', color: 'linear-gradient(135deg, #fc4a1a 0%, #f7b733 100%)' },
            { name: 'PRET√âRITO PERFECTO', key: 'pret√©rito-perfecto', color: 'linear-gradient(135deg, #4776e6 0%, #8e54e9 100%)' },
            { name: 'PLUSCUAMPERFECTO', key: 'pluscuamperfecto', color: 'linear-gradient(135deg, #134e5e 0%, #71b280 100%)' },
            { name: 'FUTURO', key: 'futuro', color: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)' },
            { name: 'CONDICIONAL', key: 'condicional', color: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)' },
            { name: 'IMPERFECTO DE SUBJUNTIVO', key: 'imperfecto-de-subjuntivo', color: 'linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%)' }
        ];

        // Node registry to track all nodes and their lines
        const nodeRegistry = {};
        let nodeIdCounter = 0;

        // Dynamic radius calculation
        function getTenseRadius() {
            return BASE_TENSE_RADIUS + (expandedCount * 80);
        }

        function getCategoryRadius() {
            return BASE_CATEGORY_RADIUS + (expandedCount * 40);
        }

        function getVerbRadius() {
            return BASE_VERB_RADIUS + (expandedCount * 30);
        }

        function autoZoom() {
            if (manualControl) return;
            
            if (expandedCount === 0) {
                scale = 0.8;
            } else if (expandedCount <= 3) {
                scale = 0.6;
            } else if (expandedCount <= 6) {
                scale = 0.45;
            } else if (expandedCount <= 10) {
                scale = 0.35;
            } else {
                scale = 0.25;
            }
            
            translateX = 0;
            translateY = 0;
            updateTransform();
        }

        // CORE FUNCTIONS
        function createNode(text, x, y, className, data = {}) {
            const id = `node-${nodeIdCounter++}`;
            const node = document.createElement('div');
            node.className = `node ${className}`;
            node.textContent = text;
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            node.style.transform = 'translate(-50%, -50%)';
            node.dataset.nodeId = id;
            
            Object.assign(node.dataset, data);
            
            nodeRegistry[id] = {
                element: node,
                x, y,
                children: [],
                lines: [],
                data
            };
            
            canvas.appendChild(node);
            return { id, element: node };
        }

        function createLine(parentId, childId) {
            const parent = nodeRegistry[parentId];
            const child = nodeRegistry[childId];
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', parent.x);
            line.setAttribute('y1', parent.y);
            line.setAttribute('x2', child.x);
            line.setAttribute('y2', child.y);
            line.dataset.parentId = parentId;
            line.dataset.childId = childId;
            
            linesContainer.appendChild(line);
            
            parent.children.push(childId);
            parent.lines.push(line);
            
            return line;
        }

        function updateNodePosition(nodeId, x, y) {
            const node = nodeRegistry[nodeId];
            node.x = x;
            node.y = y;
            node.element.style.left = `${x}px`;
            node.element.style.top = `${y}px`;
            
            // Update all lines where this node is parent
            node.lines.forEach(line => {
                line.setAttribute('x1', x);
                line.setAttribute('y1', y);
            });
            
            // Update all lines where this node is child
            Object.values(nodeRegistry).forEach(otherNode => {
                otherNode.lines.forEach(line => {
                    if (line.dataset.childId === nodeId) {
                        line.setAttribute('x2', x);
                        line.setAttribute('y2', y);
                    }
                });
            });
        }

        function removeNodeAndChildren(nodeId) {
            const node = nodeRegistry[nodeId];
            if (!node) return;
            
            // Recursively remove all children first
            const childrenCopy = [...node.children];
            childrenCopy.forEach(childId => removeNodeAndChildren(childId));
            
            // Remove all lines connected to this node
            node.lines.forEach(line => {
                if (line && line.parentNode) {
                    line.remove();
                }
            });
            
            // Remove lines where this node is a child
            Object.values(nodeRegistry).forEach(otherNode => {
                if (otherNode.lines) {
                    otherNode.lines = otherNode.lines.filter(line => {
                        if (line.dataset.childId === nodeId) {
                            if (line.parentNode) line.remove();
                            return false;
                        }
                        return true;
                    });
                }
                
                // Remove from children array
                if (otherNode.children) {
                    const index = otherNode.children.indexOf(nodeId);
                    if (index > -1) {
                        otherNode.children.splice(index, 1);
                    }
                }
            });
            
            // Remove the DOM element
            if (node.element && node.element.parentNode) {
                node.element.remove();
            }
            
            // Remove from registry
            delete nodeRegistry[nodeId];
        }

        // CREATE INITIAL STRUCTURE
        const centerNode = createNode('SPANISH\nTENSES', CENTER_X, CENTER_Y, 'center-node', { type: 'center', allVisible: 'true' });
        
        centerNode.element.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleAllTenses();
        });

        const tenseRadius = BASE_TENSE_RADIUS;
        const tenseNodesArray = [];
        
        tenses.forEach((tense, index) => {
            const angle = (index / tenses.length) * Math.PI * 2 - Math.PI / 2;
            const x = CENTER_X + Math.cos(angle) * tenseRadius;
            const y = CENTER_Y + Math.sin(angle) * tenseRadius;
            
            const tenseNode = createNode(tense.name, x, y, 'tense-node', {
                type: 'tense',
                tenseKey: tense.key,
                angle: angle,
                expanded: 'false'
            });
            
            tenseNode.element.style.background = tense.color;
            tenseNode.element.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleTense(tenseNode.id);
            });
            
            const line = createLine(centerNode.id, tenseNode.id);
            line.dataset.tenseId = tenseNode.id;
            
            tenseNodesArray.push({ nodeId: tenseNode.id, lineElement: line, angle: angle });
        });

        function repositionAllTenses() {
            const newRadius = getTenseRadius();
            
            tenseNodesArray.forEach(({ nodeId, angle }) => {
                const node = nodeRegistry[nodeId];
                if (!node) return;
                
                const x = CENTER_X + Math.cos(angle) * newRadius;
                const y = CENTER_Y + Math.sin(angle) * newRadius;
                
                updateNodePosition(nodeId, x, y);
                
                // Reposition categories if this tense is expanded
                if (node.data.expanded === 'true') {
                    repositionTenseChildren(nodeId);
                }
            });
        }

        function repositionTenseChildren(tenseNodeId) {
            const tenseNode = nodeRegistry[tenseNodeId];
            if (!tenseNode || tenseNode.data.expanded !== 'true') return;
            
            const angle = parseFloat(tenseNode.data.angle);
            const categoryRadius = getCategoryRadius();
            
            const regularAngle = angle + Math.PI / 6;
            const irregularAngle = angle - Math.PI / 6;
            
            // Find and reposition REGULAR and IRREGULAR nodes
            tenseNode.children.forEach(childId => {
                const childNode = nodeRegistry[childId];
                if (!childNode) return;
                
                if (childNode.data.category === 'regular') {
                    const x = tenseNode.x + Math.cos(regularAngle) * categoryRadius;
                    const y = tenseNode.y + Math.sin(regularAngle) * categoryRadius;
                    updateNodePosition(childId, x, y);
                    childNode.data.baseAngle = regularAngle;
                    
                    // Reposition verb children if expanded
                    if (childNode.data.expanded === 'true') {
                        repositionCategoryChildren(childId);
                    }
                } else if (childNode.data.category === 'irregular') {
                    const x = tenseNode.x + Math.cos(irregularAngle) * categoryRadius;
                    const y = tenseNode.y + Math.sin(irregularAngle) * categoryRadius;
                    updateNodePosition(childId, x, y);
                    childNode.data.baseAngle = irregularAngle;
                    
                    // Reposition verb children if expanded
                    if (childNode.data.expanded === 'true') {
                        repositionCategoryChildren(childId);
                    }
                }
            });
        }

        function repositionCategoryChildren(categoryNodeId) {
            const catNode = nodeRegistry[categoryNodeId];
            if (!catNode || catNode.data.expanded !== 'true') return;
            
            const baseAngle = parseFloat(catNode.data.baseAngle);
            const verbRadius = getVerbRadius();
            const tenseKey = catNode.data.tenseKey;
            const tenseData = verbData[tenseKey];
            
            if (catNode.data.category === 'regular') {
                catNode.children.forEach((childId, index) => {
                    const angle = baseAngle + (index - 1) * (Math.PI / 5);
                    const x = catNode.x + Math.cos(angle) * verbRadius;
                    const y = catNode.y + Math.sin(angle) * verbRadius;
                    updateNodePosition(childId, x, y);
                });
            } else {
                const totalVerbs = catNode.children.length;
                catNode.children.forEach((childId, index) => {
                    const angleSpread = Math.PI / 2.5;
                    const angle = baseAngle + ((index - (totalVerbs - 1) / 2) * (angleSpread / Math.max(totalVerbs - 1, 1)));
                    const x = catNode.x + Math.cos(angle) * verbRadius;
                    const y = catNode.y + Math.sin(angle) * verbRadius;
                    updateNodePosition(childId, x, y);
                });
            }
        }

        function toggleAllTenses() {
            const centerData = nodeRegistry[centerNode.id];
            const allVisible = centerData.data.allVisible === 'true';
            
            if (allVisible) {
                // Hide all tenses
                tenseNodesArray.forEach(({ nodeId, lineElement }) => {
                    const node = nodeRegistry[nodeId];
                    if (node) {
                        node.element.style.display = 'none';
                        lineElement.style.display = 'none';
                    }
                });
                centerData.data.allVisible = 'false';
            } else {
                // Show all tenses
                tenseNodesArray.forEach(({ nodeId, lineElement }) => {
                    const node = nodeRegistry[nodeId];
                    if (node) {
                        node.element.style.display = 'block';
                        lineElement.style.display = 'block';
                    }
                });
                centerData.data.allVisible = 'true';
            }
        }

        function toggleTense(tenseNodeId) {
            const tenseNode = nodeRegistry[tenseNodeId];
            if (!tenseNode) return;
            
            const isExpanded = tenseNode.data.expanded === 'true';
            
            if (isExpanded) {
                // Collapse - remove all children
                const childrenToRemove = [...tenseNode.children];
                childrenToRemove.forEach(childId => {
                    const child = nodeRegistry[childId];
                    if (child && child.data.expanded === 'true') {
                        expandedCount--;
                    }
                    removeNodeAndChildren(childId);
                });
                tenseNode.data.expanded = 'false';
                expandedCount--;
            } else {
                // Expand
                tenseNode.data.expanded = 'true';
                expandedCount++;
                
                const angle = parseFloat(tenseNode.data.angle);
                const categoryRadius = getCategoryRadius();
                
                // Create REGULAR and IRREGULAR nodes with wider angle
                const regularAngle = angle + Math.PI / 6;
                const irregularAngle = angle - Math.PI / 6;
                
                const regularX = tenseNode.x + Math.cos(regularAngle) * categoryRadius;
                const regularY = tenseNode.y + Math.sin(regularAngle) * categoryRadius;
                const irregularX = tenseNode.x + Math.cos(irregularAngle) * categoryRadius;
                const irregularY = tenseNode.y + Math.sin(irregularAngle) * categoryRadius;
                
                const regularNode = createNode('REGULAR', regularX, regularY, 'category-node regular-node', {
                    type: 'category',
                    category: 'regular',
                    tenseKey: tenseNode.data.tenseKey,
                    parentTense: tenseNodeId,
                    baseAngle: regularAngle,
                    expanded: 'false'
                });
                
                const irregularNode = createNode('IRREGULAR', irregularX, irregularY, 'category-node irregular-node', {
                    type: 'category',
                    category: 'irregular',
                    tenseKey: tenseNode.data.tenseKey,
                    parentTense: tenseNodeId,
                    baseAngle: irregularAngle,
                    expanded: 'false'
                });
                
                createLine(tenseNodeId, regularNode.id);
                createLine(tenseNodeId, irregularNode.id);
                
                regularNode.element.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCategory(regularNode.id);
                });
                
                irregularNode.element.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleCategory(irregularNode.id);
                });
            }
            
            // Reposition everything
            repositionAllTenses();
            autoZoom();
        }

        function toggleCategory(categoryNodeId) {
            const catNode = nodeRegistry[categoryNodeId];
            if (!catNode) return;
            
            const isExpanded = catNode.data.expanded === 'true';
            
            if (isExpanded) {
                // Collapse - remove all children
                const childrenToRemove = [...catNode.children];
                childrenToRemove.forEach(childId => removeNodeAndChildren(childId));
                catNode.data.expanded = 'false';
                expandedCount--;
            } else {
                catNode.data.expanded = 'true';
                expandedCount++;
                
                const baseAngle = parseFloat(catNode.data.baseAngle);
                const verbRadius = getVerbRadius();
                const tenseKey = catNode.data.tenseKey;
                const tenseData = verbData[tenseKey];
                
                if (catNode.data.category === 'regular') {
                    // Show -AR, -ER, -IR with more spacing
                    ['ar', 'er', 'ir'].forEach((ending, index) => {
                        const angle = baseAngle + (index - 1) * (Math.PI / 5);
                        const x = catNode.x + Math.cos(angle) * verbRadius;
                        const y = catNode.y + Math.sin(angle) * verbRadius;
                        
                        const endingNode = createNode(
                            `-${ending.toUpperCase()}\n(${tenseData.regular[ending].example})`,
                            x, y, 'ending-node',
                            { type: 'ending', ending, tenseKey, category: 'regular' }
                        );
                        
                        createLine(categoryNodeId, endingNode.id);
                        
                        endingNode.element.addEventListener('click', (e) => {
                            e.stopPropagation();
                            showConjugation(endingNode.id);
                        });
                    });
                } else {
                    // Show irregular verbs with much wider spacing
                    const irregularVerbs = Object.keys(tenseData.irregular);
                    irregularVerbs.forEach((verb, index) => {
                        const totalVerbs = irregularVerbs.length;
                        const angleSpread = Math.PI / 2.5;
                        const angle = baseAngle + ((index - (totalVerbs - 1) / 2) * (angleSpread / Math.max(totalVerbs - 1, 1)));
                        const x = catNode.x + Math.cos(angle) * verbRadius;
                        const y = catNode.y + Math.sin(angle) * verbRadius;
                        
                        const verbNode = createNode(
                            tenseData.irregular[verb].name,
                            x, y, 'verb-node',
                            { type: 'verb', verb, tenseKey, category: 'irregular' }
                        );
                        
                        createLine(categoryNodeId, verbNode.id);
                        
                        verbNode.element.addEventListener('click', (e) => {
                            e.stopPropagation();
                            showConjugation(verbNode.id);
                        });
                    });
                }
            }
            
            // Reposition everything
            repositionAllTenses();
            autoZoom();
        }

        function showConjugation(nodeId) {
            document.querySelectorAll('.conjugation-box').forEach(box => box.remove());
            
            const node = nodeRegistry[nodeId];
            const tenseKey = node.data.tenseKey;
            const tenseData = verbData[tenseKey];
            
            let conjugationData, title;
            
            if (node.data.ending) {
                conjugationData = tenseData.regular[node.data.ending].conjugations;
                title = tenseData.regular[node.data.ending].example;
            } else if (node.data.verb) {
                conjugationData = tenseData.irregular[node.data.verb].conjugations;
                title = tenseData.irregular[node.data.verb].name;
            }
            
            if (conjugationData) {
                const box = document.createElement('div');
                box.className = 'conjugation-box visible';
                
                const rect = node.element.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Position popup - try right first, then left if no space
                let left = rect.right + 20;
                let top = rect.top;
                
                // Check if popup would go off right edge
                if (left + 300 > viewportWidth) {
                    left = rect.left - 320; // Position to left instead
                }
                
                // Check if popup would go off left edge
                if (left < 10) {
                    left = 10;
                }
                
                // Check if popup would go off bottom
                if (top + 400 > viewportHeight) {
                    top = viewportHeight - 420;
                }
                
                // Check if popup would go off top
                if (top < 10) {
                    top = 10;
                }
                
                box.style.left = `${left}px`;
                box.style.top = `${top}px`;
                box.style.maxHeight = `${viewportHeight - 40}px`;
                box.style.overflowY = 'auto';
                
                let html = `<button class="close-btn" onclick="this.parentElement.remove()">√ó</button><h3>${title}</h3><div class="conjugation-list">`;
                conjugationData.forEach(([pronoun, form]) => {
                    html += `<span class="pronoun">${pronoun}</span><span class="verb-form">${form}</span>`;
                });
                html += '</div>';
                box.innerHTML = html;
                document.body.appendChild(box);
            }
        }

        // CONTROLS
        function updateTransform() {
            canvasWrapper.style.transform = `translate(calc(-50% + ${translateX}px), calc(-50% + ${translateY}px)) scale(${scale})`;
        }

        function zoomIn() {
            scale = Math.min(scale * 1.2, 3);
            manualControl = true;
            updateTransform();
        }

        function zoomOut() {
            scale = Math.max(scale / 1.2, 0.2);
            manualControl = true;
            updateTransform();
        }

        function resetView() {
            scale = 1;
            translateX = 0;
            translateY = 0;
            manualControl = false;
            updateTransform();
        }

        // DRAGGING
        container.addEventListener('mousedown', (e) => {
            if (e.target === container || e.target === canvasWrapper || e.target === canvas || e.target.tagName === 'svg') {
                isDragging = true;
                startX = e.clientX - translateX;
                startY = e.clientY - translateY;
                container.classList.add('dragging');
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                translateX = e.clientX - startX;
                translateY = e.clientY - startY;
                updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) manualControl = true;
            isDragging = false;
            container.classList.remove('dragging');
        });

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale = Math.max(0.2, Math.min(3, scale * delta));
            manualControl = true;
            updateTransform();
        });

        // TOUCH SUPPORT
        let touchStartDist = 0;
        container.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                touchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            } else if (e.touches.length === 1) {
                isDragging = true;
                startX = e.touches[0].clientX - translateX;
                startY = e.touches[0].clientY - translateY;
            }
        });

        container.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2 && touchStartDist > 0) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                scale = Math.max(0.2, Math.min(3, scale * (dist / touchStartDist)));
                touchStartDist = dist;
                manualControl = true;
                updateTransform();
            } else if (e.touches.length === 1 && isDragging) {
                translateX = e.touches[0].clientX - startX;
                translateY = e.touches[0].clientY - startY;
                updateTransform();
            }
        });

        container.addEventListener('touchend', () => {
            if (isDragging || touchStartDist > 0) manualControl = true;
            isDragging = false;
            touchStartDist = 0;
        });
    </script>
</body>
</html>
